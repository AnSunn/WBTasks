## Устные вопросы

1. Какой самый эффективный способ конкатенации строк?
  
strings.Builder, так как он:
позволяет изменять содержимое строки без создания новых экземпляров;
использует буферизацию для уменьшения затрат на реальное выделение памяти;
выделяет больший объем памяти, чем нужно на данный момент, 
и использует этот буфер для конкатенации строк. Это позволяет уменьшить количество операций выделения памяти.

2. Что такое интерфейсы, как они применяются в Go?
   
Интерфейс - это структура вида:
```bash
type iface struct {
   tab  *itab     // Если не вдаваться в подробности, то в поле tab у нас хранится информация о конкретном типе объекта, который был преобразован в интерфейс.
   data unsafe.Pointer // ссылка на реальную область памяти, в которой лежат данные изначального объекта
   }
```
Интерфейс определяет набор методов.
Обеспечивает гибкость и полиморфизм, позволяя использовать код, не зависящий от конкретного типа.

3. Чем отличаются RWMutex от Mutex?

RWMutex предоставляет блокировку для чтения и записи. В отличие от Mutex RWMutex позволяет нескольким горутинам параллельно читать данные, 
но только одна горутина может записывать данные. 
Это может улучшить производительность в случаях, когда чаще выполняются операции чтения.


4. Чем отличаются буферизированные и не буферизированные каналы?

Go не выделяет буфер для синхронных (небуферизированных) каналов, 
поэтому указатель на буфер равен nil и dataqsiz равен нулю.
Reader и sender передают данные напрямую друг другу с помощью функции sendDirect() 
– из стэка одной горутины в стэк другой горутины.
Операции отправки и приема блокируются, пока нет соответствующей готовой горутины.
При отправке данных в небуферизированный канал мы получим deadlock,
если другая горутина не будет читать из этого канала

При создании асинхронного (буферизированного) канала Go выделяет буфер и 
устанавливает значение dataqsiz, указанноe при создании в make.
Операция отправки блокируется только при заполненном буфере, и операция приема блокируется только при пустом буфере.

5. Какой размер у структуры struct{}{}?

0 байт

6. Есть ли в Go перегрузка методов или операторов?

Нет, вместо перегрузки методов и операторов, Go обычно применяет интерфейсы для достижения подобного эффекта полиморфизма

7. В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281

В случайном порядке

8. В чем разница make и new?
* new используется для выделения памяти для нового 
значения указанного типа и возвращает указатель на эту память.
* new принимает аргумент,  представляющий тип данных, для которого нужно выделить память, 
и возвращает указатель на новый экземпляр этого типа.
* new всегда возвращает указатель, даже если тип поддерживает нулевое значение. 
Он не инициализирует выделенную память (оставляет ее нулевой).


* make используется для создания слайсов, map, channel — 
типов данных, которые требуют дополнительной инициализации и внутренней структуры.
* make принимает два аргумента: тип данных и дополнительные параметры (размер буфера для слайса или канала, например).
Он возвращает инициализированный и готовый к использованию экземпляр слайса, карты или канала (не возвращает указатель).

9. Сколько существует способов задать переменную типа slice или map?

* для slice:
1) использование литерала: var s1 []int{1, 2, 3, 4}.
fmt.Println(s1) вернет [1, 2, 3, 4]
2) использование make: s2 := make([]int, 0).
fmt.Println(s2) вернет []
3) использование new: s3 := new([]int).
fmt.Println(s3) вернет &[]

* для map
1) использование литерала: m1 := map[string]int{"a": 1, "b": 2}.
   fmt.Println(m1) вернет map[a:1 b:2]
2) использование make: m2 := make(map[string]int).
   fmt.Println(m2) вернет map[]
3) использование new: m3 := new(map[string]int).
   fmt.Println(m3) вернет &map[]

10. Что выведет данная программа и почему?
```bash
func update(p *int) {
b := 2
p = &b
}

func main() {
var (
a = 1
p = &a
)
fmt.Println(*p)
update(p)
fmt.Println(*p)
}
```

вывод будет: 1 и 1

в update создаем b и присваиваем 2.
p внутри области видимости функции update p = &b, поэтому
выходя из функции update p снова становится равен &a (т. е. 1).
если хотим поменять, то надо писать *p = b

11. Что выведет данная программа и почему?

```bash
func main() {
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
wg.Add(1)
go func(wg sync.WaitGroup, i int) {
fmt.Println(i)
wg.Done()
}(wg, i)
}
wg.Wait()
fmt.Println("exit")
}
```
deadlock потому что группу надо передавать по ссылке

12. Что выведет данная программа и почему?

```bash
func main() {
n := 0
if true {
n := 1
n++
}
fmt.Println(n)
}
```
0 потому что n в if находится в другом скоупе

13. Что выведет данная программа и почему?

```bash
func someAction(v []int8, b int8) {
v[0] = 100
v = append(v, b)
}

func main() {
var a = []int8{1, 2, 3, 4, 5}
someAction(a, 6)
fmt.Println(a)
}
```
На выходе будет: [100 2 3 4 5], так как
v[0] = 100 изменяет исходный объект,
v = append(...) создает копию


14. Что выведет данная программа и почему?

```bash
func main() {
slice := []string{"a", "a"}

func(slice []string) {
slice = append(slice, "a")
slice[0] = "b"
slice[1] = "b"
fmt.Print(slice)
}(slice)
fmt.Print(slice)
}
```
На выходе будет [b b a][a a].
Сперва печатаем слайс внутри блока func,
затем печатаем слайс в main
